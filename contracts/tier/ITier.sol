// SPDX-License-Identifier: CAL

pragma solidity 0.6.12;

/// @title ITier
/// @notice `ITier` is a simple interface that contracts can
/// implement to provide membership lists for other contracts.
///
/// There are many use-cases for a time-preserving,
/// conditional membership list.
///
/// Some examples include:
///
/// - Self-serve whitelist to participate in fundraising
/// - Lists of users who can claim airdrops and perks
/// - Pooling resources with implied governance/reward tiers
/// - POAP style attendance proofs allowing access to future exclusive events
///
/// @dev Standard interface to a tiered membership.
///
/// A "membership" can represent many things:
/// - Exclusive access.
/// - Participation in some event or process.
/// - KYC completion.
/// - Combination of sub-memberships.
/// - Etc.
///
/// The high level requirements for a contract implementing ITier:
/// - MUST represent held tiers with the `Tier` enum.
/// - MUST implement `report`.
///   - The report is a `uint256` that SHOULD represent the block
/// each tier has been continuously held since encoded as `uint32`.
///   - The encoded tiers start at ONE; ZERO is implied if no tier
/// has ever been held.
///   - Tier ZERO is NOT encoded in the report, it is simply the
/// fallback value.
///   - If a tier is lost the block data is erased for that tier and
/// will be set if/when the tier is regained to the new block.
///   - If the historical block information is not available the
/// report MAY return `0x00000000` for all held tiers.
///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.
/// - SHOULD implement `setTier`.
///   - Contracts SHOULD revert with `SET_TIER` error if they cannot
/// meaningfully set a tier directly.
///     For example a contract that can only derive a membership tier
/// by reading the state of an external contract cannot set tiers.
///   - Contracts implementing `setTier` SHOULD error with
/// `SET_ZERO_TIER` if `Tier.ZERO` is being set.
/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.
///   - Contracts that cannot meaningfully set a tier are exempt.
interface ITier {
    /// 9 Possible tiers.
    /// Fits nicely as uint32 in uint256 which is helpful for
    /// internal storage concerns.
    /// 8 tiers can be achieved, ZERO is the tier when no tier has
    /// been achieved.
    enum Tier {
        ZERO,
        ONE,
        TWO,
        THREE,
        FOUR,
        FIVE,
        SIX,
        SEVEN,
        EIGHT
    }

    /// Every time a Tier changes we log start and end Tier against
    /// the account.
    /// This MAY NOT be emitted if reports are being read from the
    /// state of an external contract.
    event TierChange(
        address indexed account,
        Tier indexed startTier,
        Tier indexed endTier
    );

    /// @notice Users can set their own tier by calling `setTier`.
    ///
    /// The contract that implements `ITier` is responsible for
    /// checking eligibility and/or taking actions required to set the tier.
    ///
    /// For example, the contract must take/refund any tokens
    /// relevant to changing the tier.
    ///
    /// Obviously the user is responsible for any approvals for this
    /// action prior to calling `setTier`.
    ///
    /// When the tier is changed a `TierChange` event will be emmited as:
    /// ```
    /// event TierChange(address account, Tier startTier, Tier endTier);
    /// ```
    ///
    /// The `setTier` function includes arbitrary data as the third
    /// parameter. This can be used to disambiguate in the case that
    /// there may be many possible options for a user to achieve some tier.
    ///
    /// For example, consider the case where `THREE` can be achieved
    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user
    /// with both could use `data` to explicitly state their intent.
    ///
    /// NOTE however that _any_ address can call `setTier` for any
    /// other address.
    ///
    /// If you implement `data` or anything that changes state then
    /// be very careful to avoid griefing attacks.
    ///
    /// The `data` parameter can also be ignored by the contract
    /// implementing `ITier`. For example, ERC20 tokens are fungible
    /// so only the balance approved by the user is relevant to a tier change.
    ///
    /// The `setTier` function SHOULD prevent users from reassigning
    /// `ZERO` to themselves.
    ///
    /// The `ZERO` status represents never having any status.
    /// @dev Updates the tier of an account.
    ///
    /// The implementing contract is responsible for all checks and
    /// state changes required to set the tier.
    /// For example, taking/refunding funds/NFTs etc.
    ///
    /// Contracts may disallow directly setting tiers, preferring to
    /// derive reports from other onchain data.
    /// In this case they should `revert("SET_TIER");`.
    ///
    /// @param account Account to change the tier for.
    /// @param endTier Tier after the change.
    /// @param data Arbitrary input to disambiguate ownership (e.g.
    /// NFTs to lock).
    function setTier(
        address account,
        Tier endTier,
        bytes memory data
    )
        external;

    /// @notice A tier report is a `uint256` that contains each of
    /// the block numbers each tier has been held continously since
    /// as a `uint32`. There are 9 possible tier, starting with
    /// `ZERO` for `0` offset or "never held any tier" then working
    /// up through 8x 4 byte offsets to the full 256 bits.
    ///
    /// Low bits = Lower tier.
    ///
    /// In hexadecimal every 8 characters = one tier, starting at
    /// `EIGHT` from high bits and working down to `ONE`.
    ///
    /// `uint32` should be plenty for any blockchain that measures
    /// block times in seconds, but reconsider if deploying to an
    /// environment with significantly sub-second block times.
    ///
    /// ~135 years of 1 second blocks fit into `uint32`.
    ///
    /// `2^8 / (365 * 24 * 60 * 60)`
    ///
    /// When a user INCREASES their tier they keep all the block
    /// numbers they already had, and get new block times for each
    /// increased tiers they have earned.
    ///
    /// When a user DECREASES their tier they return to `0xFFFFFFFF`
    /// (never) for every tier level they remove, but keep their
    /// block numbers for the remaining tiers.
    ///
    /// GUIs are encouraged to make this dynamic very clear for users
    /// as round-tripping to a lower status and back is a DESTRUCTIVE
    /// operation for block times.
    ///
    /// The intent is that downstream code can provide additional
    /// benefits for members who have maintained a certain tier for/
    /// since a long time. These benefits can be provided by
    /// inspecting the report, and by on-chain contracts directly,
    /// rather than needing to work with snapshots etc.
    /// @dev Returns the earliest block the account has held each tier for
    /// continuously.
    /// This is encoded as a uint256 with blocks represented as 8x
    /// concatenated u32.
    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.
    /// The low bits represent low tiers and high bits the high tiers.
    /// Implementing contracts should return 0xFFFFFFFF for lost &
    /// never-held tiers.
    ///
    /// @param account Account to get the report for.
    /// @return The report blocks encoded as a uint256.
    function report(address account) external view returns (uint256);
}