{
    "language": "Solidity",
    "sources": {
        "./contracts/phased/Phased.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\n/// Defines all possible phases.\n/// `Phased` begins in `Phase.ZERO` and moves through each phase sequentially.\nenum Phase {\n    ZERO,\n    ONE,\n    TWO,\n    THREE,\n    FOUR,\n    FIVE,\n    SIX,\n    SEVEN,\n    EIGHT\n}\n\n/// @title Phased\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\n/// an implementing contract moves through.\n///\n/// `Phase.ZERO` is always the first phase and does not, and cannot, be set\n/// expicitly. Effectively it is implied that `Phase.ZERO` has been active\n/// since block zero.\n///\n/// Each subsequent phase `Phase.ONE` through `Phase.EIGHT` must be\n/// scheduled sequentially and explicitly at a block number.\n///\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\n/// it is not possible to schedule multiple phases ahead.\n///\n/// Multiple phases can be scheduled in a single block if each scheduled phase\n/// is scheduled for the current block.\n///\n/// Several utility functions and modifiers are provided.\n///\n/// A single hook `_beforeScheduleNextPhase` is provided so contracts can\n/// implement additional phase shift checks.\n///\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\n/// scheduled (not when the scheduled phase is reached).\n///\n/// @dev `Phased` contracts have a defined timeline with available\n/// functionality grouped into phases.\n/// Every `Phased` contract starts at `Phase.ZERO` and moves sequentially\n/// through phases `ONE` to `EIGHT`.\n/// Every `Phase` other than `Phase.ZERO` is optional, there is no requirement\n/// that all 9 phases are implemented.\n/// Phases can never be revisited, the inheriting contract always moves through\n/// each achieved phase linearly.\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\n/// phase.\n/// It is possible to call `scheduleNextPhase` several times in a single block\n/// but the `block.number` for each phase must be reached each time to schedule\n/// the next phase.\n/// Importantly there are events and several modifiers and checks available to\n/// ensure that functionality is limited to the current phase.\n/// The full history of each phase shift block is recorded as a fixed size\n/// array of `uint32`.\nabstract contract Phased {\n    /// Every phase block starts uninitialized.\n    /// Only uninitialized blocks can be set by the phase scheduler.\n    uint32 constant public UNINITIALIZED = uint32(-1);\n\n    /// `PhaseShiftScheduled` is emitted when the next phase is scheduled.\n    event PhaseShiftScheduled(uint32 indexed newPhaseBlock_);\n\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\n    uint32[8] public phaseBlocks = [\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED\n    ];\n\n    /// Pure function to reduce an array of phase blocks and block number to a\n    /// specific `Phase`.\n    /// The phase will be the highest attained even if several phases have the\n    /// same block number.\n    /// If every phase block is after the block number then `Phase.ZERO` is\n    /// returned.\n    /// If every phase block is before the block number then `Phase.EIGHT` is\n    /// returned.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param blockNumber_ Determine the relevant phase relative to this block\n    /// number.\n    /// @return The \"current\" phase relative to the block number and phase\n    /// blocks list.\n    function phaseAtBlockNumber(\n        uint32[8] memory phaseBlocks_,\n        uint32 blockNumber_\n    )\n        public\n        pure\n        returns(Phase)\n    {\n        for(uint i_ = 0; i_<8; i_++) {\n            if (blockNumber_ < phaseBlocks_[i_]) {\n                return Phase(i_);\n            }\n        }\n        return Phase(8);\n    }\n\n    /// Pure function to reduce an array of phase blocks and phase to a\n    /// specific block number.\n    /// `Phase.ZERO` will always return block `0`.\n    /// Every other phase will map to a block number in `phaseBlocks_`.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param phase_ Determine the relevant block number for this phase.\n    /// @return The block number for the phase according to the phase blocks\n    ///         list, as uint32.\n    function blockNumberForPhase(uint32[8] calldata phaseBlocks_, Phase phase_)\n        external\n        pure\n        returns(uint32)\n    {\n        return phase_ > Phase.ZERO ? phaseBlocks_[uint(phase_) - 1] : 0;\n    }\n\n    /// Impure read-only function to return the \"current\" phase from internal\n    /// contract state.\n    /// Simply wraps `phaseAtBlockNumber` for current values of `phaseBlocks`\n    /// and `block.number`.\n    function currentPhase() public view returns (Phase) {\n        return phaseAtBlockNumber(phaseBlocks, uint32(block.number));\n    }\n\n    /// Modifies functions to only be callable in a specific phase.\n    /// @param phase_ Modified functions can only be called during this phase.\n    modifier onlyPhase(Phase phase_) {\n        require(currentPhase() == phase_, \"BAD_PHASE\");\n        _;\n    }\n\n    /// Modifies functions to only be callable in a specific phase OR if the\n    /// specified phase has passed.\n    /// @param phase_ Modified function only callable during or after this\n    /// phase.\n    modifier onlyAtLeastPhase(Phase phase_) {\n        require(currentPhase() >= phase_, \"MIN_PHASE\");\n        _;\n    }\n\n    /// Writes the block for the next phase.\n    /// Only uninitialized blocks can be written to.\n    /// Only the immediate next phase relative to `currentPhase` can be written\n    /// to.\n    /// Emits `PhaseShiftScheduled` with the next phase block.\n    /// @param nextPhaseBlock_ The block for the next phase.\n    function scheduleNextPhase(uint32 nextPhaseBlock_) internal {\n        require(uint32(block.number) <= nextPhaseBlock_, \"NEXT_BLOCK_PAST\");\n        require(nextPhaseBlock_ < UNINITIALIZED, \"NEXT_BLOCK_UNINITIALIZED\");\n\n        // The next index is the current phase because `Phase.ZERO` doesn't\n        // exist as an index.\n        uint nextIndex_ = uint(currentPhase());\n        require(UNINITIALIZED == phaseBlocks[nextIndex_], \"NEXT_BLOCK_SET\");\n\n        _beforeScheduleNextPhase(nextPhaseBlock_);\n        phaseBlocks[nextIndex_] = nextPhaseBlock_;\n\n        emit PhaseShiftScheduled(nextPhaseBlock_);\n    }\n\n    /// Hook called before scheduling the next phase.\n    /// Useful to apply additional constraints or state changes on a phase\n    /// change.\n    /// Note this is called when scheduling the phase change, not on the block\n    /// the phase change occurs.\n    /// This is called before the phase change so that all functionality that\n    /// is behind a phase gate is still available at the moment of applying the\n    /// hook for scheduling the next phase.\n    /// @param nextPhaseBlock_ The block for the next phase.\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\n        internal\n        virtual\n    { } //solhint-disable-line no-empty-blocks\n}"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 100000
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}