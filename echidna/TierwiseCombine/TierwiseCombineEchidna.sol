// SPDX-License-Identifier: CAL
pragma solidity =0.8.17;

import {TierwiseCombine} from "../../contracts/tier/libraries/TierwiseCombine.sol";
import {SaturatingMath} from "../../contracts/math/SaturatingMath.sol";

import {TierConstants} from "../../contracts/tier/libraries/TierConstants.sol";

// TODO Change to test mode: assertion

/// @title TierwiseCombineEchidna
/// Wrapper around the `TierwiseCombine` library for echidna fuzz testing.
contract TierwiseCombineEchidna {
    // Values to test SaturingSub
    uint256 private _newerReport;
    uint256 private _olderReport;

    // Values to test SelectLte
    uint256[] private _reports;
    uint32 private _blockNumber;

    uint256 private _mode;
    uint256 private _logic;

    /// Allow echidna add reports to test `saturatingSub()`
    /// @param newerReport_ Block to subtract from.
    /// @param olderReport_ Block to subtract.
    function setSaturingSubReportsValues(
        uint256 newerReport_,
        uint256 olderReport_
    ) public {
        _newerReport = newerReport_;
        _olderReport = olderReport_;
    }

    function setSelectLteValues(
        uint32 blockNumber_,
        uint256[5] memory reports_,
        uint256 mode_,
        uint256 logic_
    ) public {
        _blockNumber = blockNumber_;
        _reports = reports_;
        _mode = mode_ % 3; // Alway get a values between [0 - 2]
        _logic = logic_ % 2; // Alway get a values between [0 - 1]
    }

    // SaturatingSub to be tested fuzzed with Echidna
    function echidnaSaturatingSub() external view returns (bool) {
        uint256 result = TierwiseCombine.saturatingSub(
            _newerReport,
            _olderReport
        );

        uint32[8] memory resultTiers = _splitReport(result);

        uint32[8] memory newerTiers = _splitReport(_newerReport);
        uint32[8] memory olderTiers = _splitReport(_olderReport);

        for (uint256 i = 0; i < 8; i++) {
            uint256 blockDiff = SaturatingMath.saturatingSub(
                newerTiers[i],
                olderTiers[i]
            );
            require(blockDiff == resultTiers[i], "SAT_SUB_BLOCK"); // The saturing subtraction on this block is wrong
        }

        return true;
    }

    // SelectLte to be tested fuzzed with Echidna
    function echidnaSelectLte() external view returns (bool) {
        uint256 newReport = TierwiseCombine.selectLte(
            _logic,
            _mode,
            _blockNumber,
            _reports
        );

        uint32[][8] memory allTiers = _getTiersFromReports(_reports);
        uint32[8] memory _expectedResult;

        for (uint256 i = 0; i < 8; i++) {
            // Contain all the blocks for specific level
            uint32[] memory blocksLevel = allTiers[i];

            // When _mode is set, it's intented to only received 0 or 1
            bool _flagLogic = _logic == 0
                ? _every(blocksLevel, _blockNumber)
                : _any(blocksLevel, _blockNumber);

            if (_flagLogic) {
                if (_mode == 0) {
                    // _min
                    _expectedResult[i] = _min(blocksLevel, _blockNumber);
                } else if (_mode == 1) {
                    // _max
                    _expectedResult[i] = _max(blocksLevel, _blockNumber);
                } else if (_mode == 2) {
                    // _first
                    _expectedResult[i] = _first(blocksLevel, _blockNumber);
                }
            } else {
                _expectedResult[i] = TierConstants.NEVER_TIME;
            }
        }

        return _compare(newReport, _expectedResult);
    }

    // Helper function to replicate how the tiers are splitted
    function _splitReport(
        uint256 report_
    ) private pure returns (uint32[8] memory tiers_) {
        // The tiers are splitted by each 32bits from the report
        for (uint256 i = 0; i < 8; i++) {
            tiers_[i] = uint32(uint256(report_ >> (i * 32)));
        }
    }

    // Obtain a 2D array from the reports array making easier to evealuate
    function _getTiersFromReports(
        uint256[] memory reports_
    ) private pure returns (uint32[][8] memory) {
        uint256 reportsLength = reports_.length;
        uint32[][8] memory _allTier;

        // Initialize the array
        for (uint32 i = 0; i < 8; i++) {
            uint32[] memory temp = new uint32[](reportsLength);
            _allTier[i] = temp;
        }

        // Filling array
        for (uint256 j = 0; j < reportsLength; j++) {
            uint32[8] memory _tempReport = _splitReport(reports_[j]);
            for (uint256 i = 0; i < 8; i++) {
                // [level][report]
                _allTier[i][j] = _tempReport[i];
            }
        }

        return _allTier;
    }

    // Compare one report (generated by TiewwiseCombine) and a destructured report generated by the test.
    function _compare(
        uint256 _newReport,
        uint32[8] memory _expected
    ) private pure returns (bool) {
        // Split the new report generated
        uint32[8] memory _newTiers = _splitReport(_newReport);

        // Check every block/time to each level
        for (uint256 i = 0; i < 8; i++) {
            require(_newTiers[i] == _expected[i], "It's not equal on a level");
        }

        // If all pass, then the report from selectLte is good
        return true;
    }

    // Check if blocks pass or not the every filter.
    function _every(
        uint32[] memory _blocksLevel,
        uint32 _block
    ) private pure returns (bool) {
        for (uint256 i = 0; i < _blocksLevel.length; i++) {
            if (_blocksLevel[i] > _block) {
                // One provided block does not pass the filter at the level
                return false;
            }
        }

        // All the blocks passed the filter
        return true;
    }

    // Check if blocks pass or not the any filter.
    function _any(
        uint32[] memory _blocksLevel,
        uint32 _block
    ) private pure returns (bool) {
        for (uint256 i = 0; i < _blocksLevel.length; i++) {
            if (_blocksLevel[i] <= _block) {
                // At least one block pass the filter at the level
                return true;
            }
        }

        // No block passed the filter at the level
        return false;
    }

    // Get the min value from `_blocksLevel` that is lower or equal to `_block`
    function _min(
        uint32[] memory _blocksLevel,
        uint32 _block
    ) private pure returns (uint32) {
        // Starting from the highest value possible
        uint32 _result = type(uint32).max;
        for (uint256 i = 0; i < _blocksLevel.length; i++) {
            if (_blocksLevel[i] < _result && _blocksLevel[i] <= _block) {
                _result = _blocksLevel[i];
            }
        }

        return _result;
    }

    // Get the max value from `_blocksLevel` that is lower or equal to `_block`
    function _max(
        uint32[] memory _blocksLevel,
        uint32 _block
    ) private pure returns (uint32) {
        // Starting from the lowest value possible
        uint32 _result = type(uint32).min;
        for (uint256 i = 0; i < _blocksLevel.length; i++) {
            if (_blocksLevel[i] > _result && _blocksLevel[i] <= _block) {
                _result = _blocksLevel[i];
            }
        }

        return _result;
    }

    // Get the first value from `_blocksLevel` that is lower or equal to `_block`
    function _first(
        uint32[] memory _blocksLevel,
        uint32 _block
    ) private pure returns (uint32) {
        for (uint256 i = 0; i < _blocksLevel.length; i++) {
            if (_blocksLevel[i] <= _block) {
                return _blocksLevel[i];
            }
        }

        // No block is lower or equal to `_block`
        return type(uint32).max;
    }
}
